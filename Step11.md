
# 동시성 문제 파악


## 1. 좌석 임시 예약 시나리오

하나의 좌석을 다수의 유저가 동시에 임시 예약을 하려고 한다.

다수의 유저들이 좌석 예약을 시도할 때, 가장 먼저 시도한 1명만 성공되어야 한다.

### 조건

1. 다수 요청 중 단 1건만 성공되어야 한다.
2. 성공한 단 1건만 성공되어야 하므로, 성공한 이후에는 나머지 요청들을 더 이상 처리해줄 필요가 없다. 따라서, 나머지는 대기할 필요 없이 바로 예외 발생(**`ObjectOptimisticLockingFailureException`**)시킨다.

이런 경우 낙관적 락을 사용하면 좋다.

1. 단 1건만 성공하면 되는 경우.
2. 성공한 건만 처리하고, 이후 나머지 건은 더 이상 처리할 필요가 없는 경우

따라서 좌석 예약은 낙관적 락을 적용하는 것이 좋다.

### 낙관적 락 적용

- Seat에 version 컬럼을 이용한 낙관적 락 적용.
- 구현 복잡도
    - Seat Entity에 VersionColumn을 지정하면 된다.
- 결과
    - 100명이 동시에 요청할 경우에도 1명만 성공한다.
    - 좋은 결과를 얻었다.

### 비관적 락 적용

- 구현 복잡도
    - Seat를 조회할 때, pessimistic_lock을 옵션으로 조회한다.
    - 좌석 조회부터 예약까지 트랜잭션을 유지시켜야 한다.
- 결과
    - 100명이 동시에 요청할 경우에도 1명만 성공한다.
    - 굳이 비관적 락이 필요한가에 대한 고민이 생긴다.



## 포인트 충전 시나리오

한 유저의 포인트 충전이 동시에 여러번 요청되었다.

일반적으로는 동시에 한 유저의 요청이 들어올 수 없거나 들어오면 안되는 경우가 많다.

다만, 동시 요청이 안 될 거 같다고 해도 포인트는 중요한 데이터이므로, 충전 요청은 누락되서는 안된다.

만약에 외부 결제 시스템을 거쳐야 해서, 통신으로 인한 지연이 발생했을 경우

클라이언트에서 1초 차이로 요청했던 포인트 충전이 동시에 2건이 올 수도 있다.

따라서, 모든 포인트 충전 요청은 성공적으로 처리가 되어야 한다.

### 조건

1. 다수 요청이 전부 처리되어야 한다.
2. 충전 요청 순서에 맞게 처리되어야 한다.

비관적 락을 적용하는 것이 좋다.

### 낙관적 락 적용

- User테이블에 version 컬럼을 이용한 낙관적 락 적용.
- 구현 복잡도
    - User Entity에 VersionColumn을 지정하면 된다.
- 결과
    - 100건 요청하면 1건만 성공할 것이라고 생각했으나 예상을 벗어났다.
    - 처음엔 코드를 잘못 짰는가 해서 정말 여러 번 테스트를 해보았으나 원인을 알게 되었다.
    - 유저 아이디만을 조건으로 조회하므로 100건을 동시에 요청할 경우 먼저 충전 쿼리를 호출한 요청들이 version 값을 1에서 2로 변경해버리고
    - 아직 조회조차 하지 못했던 요청들이 이후 version을 조회하면 값이 2이므로 이 요청들 중 하나는 또 업데이트를 할 수 있게 된다. 따라서 이런식으로 version 값을 계속 올리는 경우가 생긴다. 100건 요청할 경우, 최대 5건 정도 충전을 성공하게 되었다.
    - 커넥션 풀을 20개로 지정할 경우, 20건만 요청하면 대부분 1건만 성공하는 것으로 보아 커넥션 풀로 단번에 처리하는 건수에 따라 결과가 많이 달라지는 것을 보았다.
    - 좌석 예약처럼 상태를 true or false, 2가지의 경우에만 낙관적 락을 예상범위 내에서 사용할 수 있을 것 같다.

### 비관적 락 적용

- User 테이블을 조회할 때부터 포인트 충전까지 트랜잭션을 유지하고, pessimistic_lock을 적용해서 조회해야 한다.
- 구현 복잡도
    - 낙관적 락으로 테스트를 여러 번 해야 했던 경우보다 훨씬 예상 가능한 테스트 결과가 나왔다.
- 결과
    - 100번의 요청 모두 성공하였다.
    - 트랜잭션을 걸어야 하고, DB 락을 사용하기에 부담이 갈 거 같으나 (시간이 없어서 타임 체크를 못해봤습니다.) 포인트 충전과 같이 중요한 데이터에 대해서는 비관적 락이 필수적으로 보입니다.



## 좌석 결제 시나리오

결제에는 포인트 차감, 결제내역 생성, 좌석 상태 변경(예약완료)이 필요합니다.

결제내역 생성에는 락이 필요없습니다.

좌석 상태 변경은 이미 임시 예약을 해둔 상태이므로 다른 곳에서 해당 좌석에 접근할 가능성이 없습니다.

동시성이 발생하는 곳은 한 유저가 결제를 여러 번 요청할 경우입니다.

여러 번 요청할 경우, 좌석은 예약이 되더라도 포인트 차감이 두 번 이루어지기 때문에 문제가 됩니다.

따라서 포인트 차감에 락이 필요합니다.

### 조건

1. 포인트 차감이 2번 되지 않도록 낙관적 락이 필수적으로 보입니다.
2. 트랜잭션 내부에서 하나라도 처리를 실패할 경우 롤백해야 합니다.

### 낙관적 락 적용

- Seat Entity에 VersionColumn을 적용한다.
- 구현 복잡도
    - 유저가 임시 예약한 좌석, 상태까지 정확하게 설정해서 조회한다.
- 결과
    - 작업하다가 시간이 없어서 작성하다가 실패로 끝났습니다.



# 결론

- 그냥 낙관적 락, 비관적 락 코드만 적용하면 되는 거 아닌가? 하다가 예상치도 못한 결과를 내뱉는 테스트로 인해 정말 많은 깨달음을 얻었습니다.
- 분산락을 적용해보고 싶었으나 시간 부족으로 인해 적용하지 못해서 아쉽습니다.
- 여러가지 성능 테스트 및 시간 측정조차 하지 못하고 끝나서 실제로 어떤 락이 더 가볍게 쓰기 좋을지 결과를 보지 못해서 아쉽습니다.

## 고쳐야 할 점..

- 결제 서비스에 너무 많은 repository를 몰아넣어서 테스트 작성에 문제가 되었습니다. 너무 많은 의존으로 인해 3시간 동안 시간만 쓰고 실패하게 되었습니다. 이후 파사드로 옮길 필요가 있어보입니다….
- 통합 테스트로 인해 코드 리팩토링 필요를 정말 강하게 느꼈습니다.
